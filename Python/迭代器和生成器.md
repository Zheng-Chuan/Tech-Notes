# 迭代器和生成器

## Iterator和Iterable
1. 区分迭代器和可迭代对象的原则是：
   - 具有 `__iter__()` 方法的对象称为可迭代对象。该方法可获取其迭代器对象.
   - 具有 `__iter__()` 方法和 `__next__()` 方法的对象称为迭代器对象. 该方法能够自动返回下一个结果，当到达序列结尾时，引发 StopIteration 异常.


2. 迭代对象本身不一定是迭代器，但可以通过其 `__iter__()` 方法得到对应的迭代器对象.
定义可迭代对象，必须实现 `__iter__()` 方法；定义迭代器，必须实现 `__iter__()` 和 `__next__()`方法.

3. 对于可迭代对象, 可以使用`iter()` 函数得到其对应的迭代器对象，使用`next()` 函数获取该迭代器对象当前返回的元素.
```python
l = [1, 2, 3]
iterName=iter(l)
print(iterName)
print(next(iterName))
print(next(iterName))
print(next(iterName))
print(next(iterName))

'''
>>> l = [1, 2, 3]
>>> iterName=iter(l)
>>> print(iterName)
<list_iterator object at 0x0000017D355F8D00>
>>> print(next(iterName))
1
>>> print(next(iterName))
2
>>> print(next(iterName))
3
>>> print(next(iterName))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    print(next(iterName))
StopIteration
'''
```
可见, `iter()` 函数与 `__iter__()` 方法联系非常紧密, `iter()` 是直接调用该对象的`__iter__()` 方法，并将其返回结果作为自己的返回值, `next()`函数则是调用该对象的 `__next__()` 方法获取当前元素. 上例中在得到列表l最后一个元素3后再一次使用了`next( )`函数, 而此时列表l中已经没有可获取的元素了，所以抛出了异常.

因此，通俗地说，可以将迭代器简单理解为"内置了 for 循环的可迭代对象"，每使用 next( ) 函数访问一次迭代器对象, 其在返回当前元素的同时, 内部指针将指向下一个元素.