#  引用

## 引用和指针的区别
1. 其实引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。
2. 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。
3. 可以有 const 指针，但是没有 const 引用, 因为引用本来就不能改变指向，加上 const 是多此一举。
4. 指针可以有多级，但是引用只能有一级，例如，`int **p`是合法的，而`int &&r`是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个&
5. 指针和引用的自增（++）自减（--）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1；自减（--）也是类似的道理

## 引用不能绑定到临时数据
1. 其实 C++ 代码中的大部分内容都是放在内存中的，例如定义的变量、创建的对象、字符串常量、函数形参、函数体本身、new或malloc()分配的内存等，这些内容都可以用&来获取地址，进而用指针指向它们。除此之外，还有一些我们平时不太留意的临时数据，例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了寄存器中，就没法用&获取它们的地址了，也就没法用指针指向它们了。

## 什么样的临时数据会放到寄存器中
1. 寄存器离 CPU 近，并且速度比内存快，将临时数据放到寄存器是为了加快程序运行。但是寄存器的数量是非常有限的，容纳不下较大的数据，所以只能将较小的临时数据放在寄存器中。int、double、bool、char 等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中。

## 关于常量表达式
1. 常量表达式由于不包含变量，没有不稳定因素，所以在编译阶段就能求值。编译器不会分配单独的内存来存储常量表达式的值，而是将常量表达式的值和代码合并到一起，放到虚拟地址空间中的代码区。从汇编的角度看，常量表达式的值就是一个立即数，会被“硬编码”到指令中，不能寻址。

## 引用也不能指代临时数据
1. 引用和指针在本质上是一样的，引用仅仅是对指针进行了简单的封装。引用和指针都不能绑定到无法寻址的临时数据，并且 C++ 对引用的要求更加严格，在某些编译器下甚至连放在内存中的临时数据都不能指代。

## 编译器会为const引用创建临时变量
1. 引用不能绑定到临时数据，这在大多数情况下是正确的，但是当使用 const 关键字对引用加以限定后，引用就可以绑定到临时数据了
> 为什么编译器为常引用创建临时变量是合理的，而为普通引用创建临时变量就不合理呢？

1. 我们知道，将引用绑定到一份数据后，就可以通过引用对这份数据进行操作了，包括读取和写入（修改）；尤其是写入操作，会改变数据的值。而临时数据往往无法寻址，是不能写入的，即使为临时数据创建了一个临时变量，那么修改的也仅仅是临时变量里面的数据，不会影响原来的数据，这样就使得引用所绑定到的数据和原来的数据不能同步更新，最终产生了两份不同的数据，失去了引用的意义。
2. const 引用和普通引用不一样，我们只能通过 const 引用读取数据的值，而不能修改它的值，所以不用考虑同步更新的问题，也不会产生两份不同的数据，为 const 引用创建临时变量反而会使得引用更加灵活和通用。

## const引用与转换类型
### 为什么「编译器禁止指针指向不同类型的数据」是合理的呢？
以 int 类型的数据和float *类型的指针为例，我们让float *类型的指针强制指向 int 类型的数据，看看会发生什么。下面的代码演示了这一幕：
```c++
#include <cstdio>
using namespace std;
int main(){
    int n = 100;
    float *p = (float*)&n;
    *p = 19.625;
    printf("%d\n", n);
    return 0;
}
//运行结果：
1100808192
```
将 float 类型的数据赋值给 int 类型的变量时，会直接截去小数部分，只保留整数部分，本例中将 19.626 赋值给 n，n 的值应该为 19 才对，这是我们通常的认知。但是本例的输出结果是一个毫无意义的数字，它与 19 没有任何关系，这颠覆了我们的认知。

虽然 int 和 float 类型都占用 4 个字节的内存，但是程序对它们的处理方式却大相径庭：
对于 int，程序把最高 1 位作为符号位，把剩下的 31 位作为数值位；
对于 float，程序把最高 1 位作为符号位，把最低的 23 位作为尾数位，把中间的 8 位作为指数位。

n 存储的二进制位是不变的，只是当以不同的形式展现出来的时候，我们看到的结果是不一样的。读者可以尝试通过`printf("%f\n", *p);`输出 n 的值，得到的结果就是 `19.625000`。

让指针指向「相关的（相近的）但不是严格对应的」类型的数据，表面上看起来是合理的，但是细思极恐，这样会给程序留下很多意想不到的、难以发现的 Bug，所以编译器禁止这样做是非常合理的。当然，如果你想通过强制类型转换达到这个目的（如上例所示），那编译器也会放任不管，给你自由发挥的余地。

### const 引用与类型转换
类型严格一致」是为了防止发生让人匪夷所思的操作，但是这条规则仅仅适用于普通引用，当对引用添加 const 限定后，情况就又发生了变化，编译器允许引用绑定到类型不一致的数据。请看下面的代码：
```c++
int n = 100;
int &r1 = n;  //正确
const float &r2 = n;  //正确
char c = '@';
char &r3 = c;  //正确
const int &r4 = c;  //正确 
```
当引用的类型和数据的类型不一致时，如果它们的类型是相近的，并且遵守「数据类型的自动转换」规则，那么编译器就会创建一个临时变量，并将数据赋值给这个临时变量（这时候会发生自动类型转换），然后再将引用绑定到这个临时的变量，这与「将 const 引用绑定到临时数据时」采用的方案是一样的。

结合上节讲到的知识，总结起来说，给引用添加 `const` 限定后，不但可以将引用绑定到临时数据，还可以将引用绑定到类型相近的数据，这使得引用更加灵活和通用，它们背后的机制都是临时变量。