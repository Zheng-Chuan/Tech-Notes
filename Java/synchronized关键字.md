# 简介
被synchronize修饰的类/对象/方法/代码, 在同一个时刻最多只能有一个线程来执行(读/写), 以此来保证并发安全的效果.

# 用法
## 对象锁
1. 修饰一个普通方法(不能是静态方法) -> 默认锁对象为this当前实例对象.
2. 修饰在代码块上 -> 可以传this, 也可以自己指定其他对象作为锁
	```
	synchronized (this) {
		#code blcok here
	} 
	```
	或者
	```
	synchronized (otherObject) {
		#clode block here
	}
	```
## 类锁
Java语言中, 一个类可以有很多个普通对象, 但是一个类有且只有一个Class对象, 所谓类锁, 不过是Class对象而已
1. 修饰静态方法, synchronized加在static方法上
2. 修饰在代码块上 -> 传的参数是 `*.class`
	```
	synchronized (*.class) {
		#code blcok here
	} 
	```
	
## 多线程访问同步方法的7种情况
1. 两个线程同时访问一个对象的同步方法
2. 两个线程访问的是两个对象的同步方法
3. 两个线程访问的是synchronized修饰的静态方法
4. 两个线程访问同步方法和非同步方法
5. 访问同一个对象的不同的普通同步方法
6. 同时访问静态synchronized和非静态synchronized方法
7. 方法抛出异常后, 会释放锁

### 分析方法
就看synchronized修饰的是什么东西, 多个线程是否在尝试执行同一个实例的方法/同一个类的static方法

### 核心思想
1. 一把锁只能同时被一个线程获取, 没有拿到锁的线程必须等待
2. 每个实例都对应有自己的一把锁, 不同实例之间互不影响
3. 锁对象是*.class以及synchronized修饰的是static方法的时候, 所有对象共用同一把类锁
4. 无论是方法正常执行完毕或者方法抛出异常, 都会释放锁



# 性质
## 可重入
同一线程的外层函数获得锁之后, 内存函数可以直接再次获取该锁
三种情况
1. 对于同一个方法是可重入的
2. 可重入不要求是同一个方法
3. 可重入不要求是同一个类
## 不可中断
一个线程在获得一个锁后, 如果其他线程想获得该锁, 那么它只能选择进入阻塞或者等待状态, 也就是说, 其他线程此时不能中断已经获得锁并且在执行的线程.

## 缺点
### 效率低
1. 释放锁的情况少: 只能执行完成或者抛出异常
2. 一个线程试图获得锁时, 不能设置超时
3. 不能中断一个正在试图获得锁的线程

### 不够灵活
1. 加锁和释放的时机单一, 每个锁仅有一个条件 (某个对象), 可能是不够的
2. 无法知道是否成果获得了锁

### 常见面试问题
1. 使用注意点: 锁对象不能为空, 作用域不能过大, 需要避免死锁
2. 多线程访问同步方法的7中情况