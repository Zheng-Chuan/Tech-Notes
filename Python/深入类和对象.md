# 深入类和对象


## 鸭子类型


## 抽象基类
1. 对应Java中的接口吗?
2. 主要的用处是什么?
3. `__all__()`中包含了哪些抽象基类?


## isinstance和type的区别
1. `isinstance()`:检查是否是该类的实例或者该类的子类的实例
2. `type()`:检查是否是该类的实例, 但是不检查是否是某个类的子类的实例


## 类变量和实例变量
1. 类变量: 一个类的所有实例共享一份拷贝
2. 实例变量: 每一个该类的实例都有一份对应的拷贝
3. 注意点:类变量可以通过 `Class.var` 或者 `instance.var`的方式来访问 但是只能通过`Class.var`的方式来赋值!!如果通过`instance.var`来赋值的话, python解释器其实不会修改类变量 而是创建了一个新的 ***实例变量*** 并且完成了赋值!!


## 类方法 静态方法 实例方法
1. 静态方法
    ```python
        @staticmethod
        def parse_string()://没有self!!!
            pass
    ```
2. 类方法
    ```python
        @classmethod
        def parse_string(cls, my_birthday)://cls只是形式参数 可以是任意的
            pass
    ```
3. 类方法和静态方法的区别:


## 数据封装和私有属性
1. Python中如何实现类似Java中的 **private** 成员变量呢
    ```python
        class User():
            def __init__(self, birthday):
                self.__birthday = birthday

        user = User(1997)
        print(user.__birthday) //报错
        print(_User__birthday) //正常
    ```


## Python对象的自省机制
1. 通过一定的机制 查询到对象的内部结构
2. 通过`__dict__`查询对象的属性
3. 通过`user.name`, 是可以访问到父类的属性的
4. `__dict__`是每一个对象自带的一个内置字典, 可以通过`user.__dict__["new_attr"] = new_value`的方式来增加新属性

## `super()`函数
1. `super()`其实不(仅仅)是简单调用父类的代码, 而是执行 **MRO**算法的下一个节点的对应的方法


## 上下文管理器 - `with`语句
1. 可以给通过给我们自己定义的类添加类似`__enter__()` `__exit__()`来增强我们的类, 使它满足 **上下文管理器协议** 这样这个类就可以用如下方式进行使用
```python
class Sample:
    def __enter__():
        print("start")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("end")

    def do_someting(self):
        print("doing something")

with Sample() as sample:
    sample.do_something()

# start
# doing something
# end 
```

## 上下文管理器 - contextlib
```python
import contextlib

@contextlib.contextmanager
def file_open(filename):
    print("file opening")
    yield {}
    print("file opened")

wiht file_open("chuan.txt") as f:
    print("process the file here")

    
```

