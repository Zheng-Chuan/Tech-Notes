# Java 语言基础

## 知识
1. `String`被`final`修饰, 被初始化后不可更改.
2. 内部为 `private final byte[] value;`
3. `String`因为不可修改, 所以线程安全.
4. `StringBuilder`线程不安全 `StringByffer`线程安全, 原因在于它使用`synchronized`进行同步.
5. `String a = new String("aaa");` 这种初始化方式不会将其加入字符串常量池, 但是使用`a.intern()`方法会将其加入字符串常量池中. 而`String a = "aaa";`则直接将该字符串放到字符串常量池中.
6. 字符串常量池在 Java 7 以前是放在永久代中的, 但是在 Java 7 以后就放在堆中了. 



## 疑问
1. JVM对于没有放在字符串常量池中的字符串, 会将其当做一个普通对象管理吗.
2. 为什么`String a = "aaa";`会直接将字符串放到堆中.
3. String被final修饰有什么好处.
4. 反射的使用场景有哪些.
   

## 文章
1. https://stackoverflow.com/questions/10578984/what-is-java-string-interning
2. https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html
3. https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder




## 面试问题

### 1. 什么是 JVM ？为什么 Java 被称作是"平台无关的编程语言"
Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。

Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。



### 2. JDK JRE JVM 分别是什么关系
JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：用于编译 Java 程序的 javac 命令、用于启动 JVM 运行 Java 程序的 Java 命令、用于生成文档的 Javadoc 命令以及用于打包的 jar 命令等等。

JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。

JVM 即为 Java 虚拟机，提供了字节码文件（.class）的运行环境支持。 简单说，就是 JDK 包含 JRE 包含 JVM。



### 3. Java 支持的数据类型有哪些
Java 支持的数据类型包括基本数据类型和引用类型。

基本数据类型
整数：byte(1个字节)，short(2个字节)，int(4个字节)，long(8个字节)
字符：char(2个字节)
浮点：float(4个字节)，double (8个字节)
布尔：boolean(没有明确说明)
整数默认 int 型，小数默认是 double 型。

Float 和 Long 类型的必须加后缀。比如 float f = 100f。
首先知道 String 是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。

引用类型
类、接口、数组等。



### 4. 什么是自动拆装箱
自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以 new 对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者 toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。



### 5. 什么是封装继承多态
1. 封装
    封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
2. 继承
    面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
3. 多态
    多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 实现多态，有二种方式，覆盖，重载。



### 6. & 与 && 的区别
1. & 运算符有两种用法：
   按位与
   逻辑与
2. && 运算符是短路与运算
   
逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&& 之所以称为短路运算是因为，如果 && 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。
很多时候我们可能都需要用 && 而不是 &，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：
`username != null && !username.equals("")`
二者的顺序不能交换，更不能用 & 运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 `NullPointerException` 异常。
注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。



### 7. 什么是值传递和引用传递？
值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。

引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。

一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。值得注意的一个点是Java的String 也是值传递 String类型的是final修饰的，所以每次修改，相当于new一个 String



### 8. 是否可以在 static 环境中访问非 static 变量？
static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。



### 9. Java 中的方法覆盖（Overriding）和方法重载（Overloading）是什么
Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。



### 10. Java 支持多继承么？
Java 中类不支持多继承，只支持单继承

Java 类可以实现多个接口

Java 中的接口支持多继承，即一个子接口可以有多个父接口



### 11. 接口和抽象类的区别是什么？
从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 接口中所有的方法**隐含的都是抽象的**，而抽象类则可以同时包含抽象和非抽象的方法。

类可以实现很多个接口，但是只能继承一个抽象类。类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。

抽象类可以在不提供接口方法实现的情况下实现接口。 Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public。

接口不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。也可以参考 JDK8 中抽象类和接口的区别。



### 12. final, finally, finalize 的区别

final: 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.
finally:是异常处理语句结构的一部分，表示总是执行.
finalize: 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.



### 13. 用最有效率的方法计算 2 乘以 8？
2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方)



### 14. String和StringBuilder、StringBuffer的区别？
Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。
其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。
而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。



### 15. 说说反射的用途及实现
Java 反射机制是一个非常强大的功能，在很多的项目比如 Spring，MyBatis 都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决 Java 泛型擦除等令人苦恼的问题。
获取一个对象对应的反射类，在 Java 中有下列方法可以获取一个对象的反射类

通过 getClass() 方法
通过 Class.forName() 方法
使用 类.class
通过类加载器实现，getClassLoader()



### 16. `==`和`equals()`的区别
1. `==`常用于比较原生类型，而`equals()`方法用于检查对象的相等性。
2. 如果`==`和`equals()`用于比较对象，当两个引用地址相同，`==`返回 `true`。而 `equals()` 可以返回 `true` 或者 `false` 主要取决于重写的具体实现。最常见的一个例子，字符串的比较，不同情况 `==` 和 `equals()` 返回不同的结果。


