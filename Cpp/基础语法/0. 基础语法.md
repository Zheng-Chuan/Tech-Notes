# 基础语法

## `Const` 在 C 和 C++ 中的不同

### 是否在内存中

在C语言中, 编译器会先到 m 所在的内存取出一份数据, 再将这份数据赋给 n. 而在C++中, 编译器会直接将 10 赋给 n, 没有读取内存的过程, 和int n = 10;的效果一样. C++ 中的常量更类似于#define命令, 是一个值替换的过程, 只不过#define是在预处理阶段替换, 而常量是在编译阶段替换.

C++ 对 const 的处理少了读取内存的过程, 优点是提高了程序执行效率, 缺点是不能反映内存的变化, 一旦 const 变量被修改, C++ 就不能取得最新的值.

有读者提出疑问, const 变量不是禁止被修改吗？对, 这种说法没错！不过这只是语法层面上的限制, 通过指针仍然可以修改. 下面的代码演示了如何通过指针修改 const 变量:

```c++

#include <stdio.h>

int main(){
    const int n = 10;
    int *p = (int*)&n;  //必须强制类型转换
    *p = 99;  //修改const变量的值
    printf("%d\n", n);
    return 0;
}
```

> 注意, &n得到的指针的类型是const int *, 必须强制转换为int*后才能赋给 p, 否则类型是不兼容的.

> 当然, 这种修改常量的变态代码在实际开发中基本不会出现, 本例只是为了说明C和C++对 const 的处理方式的差异: C语言对 const 的处理和普通变量一样, 会到内存中读取数据. C++ 对 const 的处理更像是编译时期的#define, 是一个值替换的过程.

### 作用域不同

C和C++中全局 const 变量的作用域相同, 都是当前文件, 不同的是它们的可见范围: C语言中 const 全局变量的可见范围是整个程序, 在其他文件中使用 extern 声明后就可以使用. 而C++中 const 全局变量的可见范围仅限于当前文件, 在其他文件中不可见, 所以它可以定义在头文件中, 多次引入后也不会出错.

## `new` 和 `delete`

为了消除函数调用的时空开销, C++ 提供一种提高效率的方法, 即在编译时将函数调用处用函数体替换, 类似于C语言中的宏展开. 这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function）, 又称内嵌函数或者内置函数.

使用内联函数的缺点也是非常明显的, 编译后的程序会存在多份相同的函数拷贝, 如果被声明为内联函数的函数体非常大, 那么编译后的程序体积也将会变得很大, 所以再次强调, 一般只将那些短小的、频繁调用的函数声明为内联函数.

最后需要说明的是, 对函数作 inline 声明只是程序员对编译器提出的一个建议, 而不是强制性的, 并非一经指定为 inline 编译器就必须这样做. 编译器有自己的判断能力, 它会根据具体情况决定是否这样做.

## `inline` 内联函数

### 主要目的

- 消除函数调用时的开销
- 取代带参数的宏

### 如何规范使用

更为严格地说, 内联函数不应该有声明, 应该将函数定义放在本应该出现函数声明的地方, 这是一种良好的编程风格

## 默认参数

1. C++规定, 默认参数只能放在形参列表的最后, 而且一旦为某个形参指定了默认值, 那么它后面的所有形参都必须有默认值.
2. C++ 规定, 在给定的作用域中只能指定一次默认参数.

### 多次声明同一个函数

在多文件编程时, 我们通常的做法是将函数声明放在头文件中, 并且一个函数只声明一次, 但是多次声明同一函数也是合法的.

不过有一点需要注意, 在给定的作用域中一个形参只能被赋予一次默认参数. 换句话说, 函数的后续声明只能为之前那些没有默认值的形参添加默认值, 而且该形参右侧的所有形参必须都有默认值.

```c++
#include <iostream>
using namespace std;

//多次声明同一个函数
void func(int a, int b, int c = 36);
void func(int a, int b = 5, int c);

int main(){
    func(99);
    return 0;
}
```

这种声明方式是正确的. 第一次声明时为 c 指定了默认值, 第二次声明时为 b 指定了默认值. 第二次声明是添加默认参数. 需要提醒的是, 第二次声明时不能再次给 c 指定默认参数, 否则就是重复声明同一个默认参数.

## 函数重载

### 概念

函数的重载的规则:
函数名称必须相同.
参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）.
函数的返回类型可以相同也可以不相同.
仅仅返回类型不同不足以成为函数的重载.

注意, 参数列表不同包括参数的个数不同、类型不同或顺序不同, 仅仅参数名称不同是不可以的. 函数返回值也不能作为重载的依据.

### 重载决议

C++代码在编译时会根据参数列表对函数进行重命名, 例如void Swap(int a, int b)会被重命名为_Swap_int_int, void Swap(float x, float y)会被重命名为_Swap_float_float. 当发生函数调用时, 编译器会根据传入的实参去逐个匹配, 以选择对应的函数, 如果匹配失败, 编译器就会报错, 这叫做重载决议（Overload Resolution）.

不同的编译器有不同的重命名方式, 这里仅仅举例说明, 实际情况可能并非如此. +

从这个角度讲, 函数重载仅仅是语法层面的, 本质上它们还是不同的函数, 占用不同的内存, 入口地址也不一样.

当重载函数有多个参数时也会产生二义性, 而且情况更加复杂. C++ 标准规定, 如果有且只有一个函数满足下列条件, 则匹配成功:
该函数对每个实参的匹配都不劣于其他函数.
至少有一个实参的匹配优于其他函数.

```c++
void func(int, int);  //①
void func(char, int, float);  //②
void func(char, long, double);  //③

short n = 99;
func('@', n, 99);
func('@', n, 99.5);
```

函数原型func(int, int)只有两个参数, 而函数调用有三个参数, 很容易看出来不匹配, 在初次筛选时就会被过滤掉, 接下来我们只讨论②③个函数原型.

1. 先来看第一个函数调用. 如果只考虑第一个实参'@', 那么②③两个函数都能够精确匹配, 谁也不比谁优秀, 是平等的. 如果只考虑第二个实参n, 对于②, 需要把 short 提升为 int（类型提升）, 对于③, 需要把 short 转换为 long（类型转换）, 类型提升的优先级高于类型转换, 所以②胜出. 如果只考虑第三个实参99, ②③都要进行类型转换, 没有哪一个能胜出, 它们是平等的.
从整体上看, ②③在第一、三个实参的匹配中是平等的, 但②在第二个实参的匹配中胜出, 也就是说, ②对每个实参的匹配都不劣于③, 但有一个实参的匹配优于③, 所以②最终脱颖而出, 成为被调用函数.

1. 再来看第二个函数调用. 只考虑第一个实参时②③是平等的, 没有谁胜出. 只考虑第二个实参时②胜出. 只考虑第三个实参时, ②需要类型转换, ③能够精确匹配, 精确匹配的优先级高于类型转换, 所以③胜出.
从整体上看, ②③在第一个实参的匹配中是平等的, ②在第二个实参的匹配中胜出, ③在第三个实参的匹配中胜出, 它们最终“打成了平手”, 分不清孰优孰劣, 所以编译器不知道如何抉择, 会产生二义性错误.

## `extern "C"`

使用 C 和 C++ 进行混合编程时, 考虑到对函数名的处理方式不同, 势必会造成编译器在程序链接阶段无法找到函数具体的实现, 导致链接失败.

幸运的是, C++ 给出了相应的解决方案, 即借助 extern "C", 就可以轻松解决 C++ 和 C 在处理代码方式上的差异性.

extern 是 C 和 C++ 的一个关键字, 但对于 extern "C", 读者大可以将其看做一个整体, 和 extern 毫无关系.

extern "C" 既可以修饰一句 C++ 代码, 也可以修饰一段 C++ 代码, 它的功能是让编译器以处理 C 语言代码的方式来处理修饰的 C++ 代码.

```c++
#ifdef __cplusplus
extern "C" void display();
#else
void display();
#endif
```

```c++
#ifdef __cplusplus
extern "C" {
#endif

void display();

#ifdef __cplusplus
}
#endif
```

由此可以看出, extern "C" 大致有 2 种用法, 当仅修饰一句 C++ 代码时, 直接将其添加到该函数代码的开头即可. 如果用于修饰一段 C++ 代码, 只需为 extern "C" 添加一对大括号{}, 并将要修饰的代码囊括到括号内即可.
