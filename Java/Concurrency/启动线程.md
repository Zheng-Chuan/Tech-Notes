# 启动线程的正确和错误方式
**一句话概括 -> 应该用`start()`启动线程, 而不是直接`run()`方法**

## `start()`的含义
  1. 启动新线程
      - 请求JVM的在空闲的时候启动新的线程, 不代表执行`start()`会立即执行, 由线程调度器决定
      - `start()`会让两个线程同时运行, 第一个是创建子线程的这个"父线程", 第二个是被创建的子线程
  2. 准备工作
      - 新创建的线程在启动前需要一些准备工作
      - 准备工作完成后, 子线程状态为0, 该子线程才会被JVM调度, 等待分配CPU资源
  3. 不能重复调用`start()`
      - 首先, 检查线程状态, 如果线程状态不是0, (0表示not yet started) 那么会报错
        ```java
        if (threadStatus != 0) 
            throw new IlleagalThreadStateException();
        ```
      - 加入线程组
      - 调用`start0()`这个native方法
  
## `run()`的本质
  1. 要么被重写, 要么调用`target.run()`
   

## 常见面试问题
  1. 如果一个线程两次调用`start()`方法会出现什么情况? 为什么?
  答:
       - 先解释start()做哪些事 (准备工作, 检查子线程状态, 若之前该子线程没被start过, 则该子线程状态设置为0, 供JVM调度).
       - 引申, 引出线程的六个状态,描述清楚状态转换图
  2. 既然`start()`会调用`run()`方法, 为什么我们选择调用`start()`方法, 而不是直接调用run()方法呢?
  答:
      - 因为创建该子线程的父线程执行start()方法后, 会正确的为子线程做一系列准备工作, 并且正确地设置子线程的状态.
      - 如果直接调用run()方法的话, 其实就是执行的那经典的三行代码: 要么执行target.run() 要么执行overwrite的run()方法. 并不能设置线程状态.
        ```java
        void run(){
          if (target != null) {
              target.run();
          }
        }
        ```