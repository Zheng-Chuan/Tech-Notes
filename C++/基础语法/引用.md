#  引用

## 引用和指针的区别
1. 其实引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。
2. 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。
3. 可以有 const 指针，但是没有 const 引用, 因为引用本来就不能改变指向，加上 const 是多此一举。
4. 指针可以有多级，但是引用只能有一级，例如，`int **p`是合法的，而`int &&r`是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个&
5. 指针和引用的自增（++）自减（--）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1；自减（--）也是类似的道理

## 引用不能绑定到临时数据
1. 其实 C++ 代码中的大部分内容都是放在内存中的，例如定义的变量、创建的对象、字符串常量、函数形参、函数体本身、new或malloc()分配的内存等，这些内容都可以用&来获取地址，进而用指针指向它们。除此之外，还有一些我们平时不太留意的临时数据，例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了寄存器中，就没法用&获取它们的地址了，也就没法用指针指向它们了。

## 什么样的临时数据会放到寄存器中
1. 寄存器离 CPU 近，并且速度比内存快，将临时数据放到寄存器是为了加快程序运行。但是寄存器的数量是非常有限的，容纳不下较大的数据，所以只能将较小的临时数据放在寄存器中。int、double、bool、char 等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中。

## 关于常量表达式
1. 常量表达式由于不包含变量，没有不稳定因素，所以在编译阶段就能求值。编译器不会分配单独的内存来存储常量表达式的值，而是将常量表达式的值和代码合并到一起，放到虚拟地址空间中的代码区。从汇编的角度看，常量表达式的值就是一个立即数，会被“硬编码”到指令中，不能寻址。

## 引用也不能指代临时数据
1. 引用和指针在本质上是一样的，引用仅仅是对指针进行了简单的封装。引用和指针都不能绑定到无法寻址的临时数据，并且 C++ 对引用的要求更加严格，在某些编译器下甚至连放在内存中的临时数据都不能指代。

## 编译器会为const引用创建临时变量
1. 引用不能绑定到临时数据，这在大多数情况下是正确的，但是当使用 const 关键字对引用加以限定后，引用就可以绑定到临时数据了
> 为什么编译器为常引用创建临时变量是合理的，而为普通引用创建临时变量就不合理呢？

1. 我们知道，将引用绑定到一份数据后，就可以通过引用对这份数据进行操作了，包括读取和写入（修改）；尤其是写入操作，会改变数据的值。而临时数据往往无法寻址，是不能写入的，即使为临时数据创建了一个临时变量，那么修改的也仅仅是临时变量里面的数据，不会影响原来的数据，这样就使得引用所绑定到的数据和原来的数据不能同步更新，最终产生了两份不同的数据，失去了引用的意义。
2. const 引用和普通引用不一样，我们只能通过 const 引用读取数据的值，而不能修改它的值，所以不用考虑同步更新的问题，也不会产生两份不同的数据，为 const 引用创建临时变量反而会使得引用更加灵活和通用。

## const引用与转换类型
